<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>

<body>
    <script type="text/javascript">
        // 定义一个Person类
        /* class Person {
        // 构造器方法
            constructor(name, age) {
                // 构造器中的this是谁？ --- Person的实例对象
                this.name = name
                this.age = age
            }
         // 一般方法
         // speak是放在哪里的?  Person的原型对象（Person.prototype）上，原型上的方法一般都是给该类的实例对象用的
            speak() {
                // speak中的this是谁？  Person的实例对象 ->此句不完整
                // 应该为：通过person实例调用speak时，speak中的this就是person实例
                console.log(`我的名字是${this.name},年龄是${this.age}`);
            }
        } */
        /* const p = new Person('老刘', 18)
        console.log(Person.prototype);
        console.log(p);
        p.speak() 
        p.speak().call({a:1,b:2})  //此时this就不是p了
        */

        // 定义一个Student类，继承于Person
        /* class Student extends Person {
            constructor(name, age, grade) {
                super(name, age)    // super的调用必须在this之前，且若有继承还有写构造器必须写super
                this.grade = grade
            }
            // 重写从父类继承过来的方法
            speak() {
                console.log(`我的名字是${this.name},年龄是${this.age},我的年级是${this.grade}`);
            }
            study() {
                console.log(`我的年级是:${this.grade},我在努力的学习`);
            }
        }
        // 类若有继承，可不写构造函数，按父类的构造函数传参即可（即：构造函数不是必须的）
        const s = new Student('强哥', 13, '高一')
        console.log(s);
        s.study(); */

        // 类里面还可以写赋值语句
        class Dog {
            name = 'tom'
            // b = 2  // 这么写b会到类的实例对象上
            static b = 2  // 这么写b会到类的原型对象上
        }
        const d = new Dog()
        console.log(d);

        console.log(Dog.b);
    </script>
</body>

</html>
